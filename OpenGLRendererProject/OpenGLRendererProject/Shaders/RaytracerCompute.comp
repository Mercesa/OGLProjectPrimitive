#version 430 core

layout (local_size_x = 16, local_size_y = 16) in;


layout (rgba32f, binding = 0) uniform highp image2D img_output;

float intersectPlane(vec3 n, vec3 planeOrigin, vec3 rayOrigin, vec3 rayDirection)
{
	float t = 0;

	float denom = dot(n,rayDirection);

	if(denom > 0.000001)
	{
		vec3 p0l0 = planeOrigin - rayOrigin;
		t = dot(p0l0, n)/denom;

		return t;
	}
	return -1;
}

void main(void)
{             
	vec4 pixel = vec4(0.0, 0.0, 0.0, 1.0);

	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

	float max_x = 5.0;
	float max_y = 5.0;
	ivec2 dims = imageSize(img_output); // fetch image dimensions


	float x = (float(pixel_coords.x * 2 - dims.x) / dims.x);
	float y = (float(pixel_coords.y * 2 - dims.y) / dims.y);
	
	
	vec3 ray_o = vec3(x * max_x, y * max_y, 0.0);
	vec3 ray_d = vec3(0.0, 0.0, -1.0); // ortho

	vec3 sphere_c = vec3(0.0, 0.0, -10.0);
	float sphere_r = 1.0;
	
	// sphere center to ray origin
	vec3 omc = ray_o - sphere_c;

	// Dot ray direction and the vec from sphere center to ray origin
	float b = dot(ray_d, omc);
	

	float c = dot(omc, omc) - sphere_r * sphere_r;
	float bsqmc = sqrt(b * b - c);
	// hit one or both sides
	

	float t = intersectPlane(normalize(vec3(0.0, -0.9, 0)), vec3(0.0, -6.0, 0), ray_o, ray_d);

	vec3 lightPos = vec3(0.0f, 20.0f, 1.0f);
	vec3 hitPoint = ray_o + ray_d * t; 

	if(t != -1)
	{
		vec3 L = normalize(lightPos - hitPoint);
		float dP = dot(L, vec3(0.0, 0.0, 1.0));

		//dP = max(dP, 0.0);
		pixel = vec4(1.0, 1.0, 1.0, 1.0);
	}
	
	if (bsqmc >= 0.0) {
	  pixel = vec4(0.4, 0.4, 1.0, 1.0);
	}

	
	


	imageStore(img_output, pixel_coords, pixel);

}